<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blob Maker version 1.0</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: "Courier New", monospace;
      background-color: #efefef;
      color: #000;
    }
    .window {
      width: 800px;
      margin: 40px auto;
      border: 2px solid #000;
      background-color: #fff;
      box-shadow: 4px 4px 0px #000;
      position: relative;
    }

    /* TITLE BAR */
    .title-bar {
      background-color: #c0c0c0;
      border-bottom: 2px solid #000;
      padding: 4px 8px;
      display: flex;
      gap: 12px;
      align-items: center;
      position: relative;
    }
    .menu-bar {
      display: flex;
      gap: 16px;
    }
    .menu-bar span {
      font-weight: bold;
      cursor: pointer;
      position: relative;
    }
    .menu-bar span:hover {
      text-decoration: underline;
    }
    .submenu {
      display: none;
      position: absolute;
      top: 24px;
      left: 0;
      background-color: #c0c0c0;
      border: 2px solid #000;
      padding: 4px;
      flex-direction: column;
      gap: 4px;
      z-index: 999;
    }
    .submenu span {
      display: block;
      padding: 2px 6px;
      cursor: pointer;
    }
    .submenu span:hover {
      background-color: #d9d9d9;
    }
    #exportSubmenu { width: 160px; }
    #fileSubmenu { width: 200px; }

    #mobileWarning {
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background: #fff;
       color: #000;
       font-family: sans-serif;
       display: flex;
       align-items: center;
       justify-content: center;
       text-align: center;
       z-index: 10000;
       padding: 20px;
     }

    .reset-icon {
      margin-left: auto;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      text-decoration: none;
      padding: 0 8px;
    }
    .reset-icon:hover {
      background-color: #d9d9d9;
    }

    /* CONTENT AREA */
    .content {
      display: flex;
    }

    /* TOOLBAR with separate sections */
    .toolbar {
      width: 140px;
      border-right: 2px solid #000;
      background-color: #d9d9d9;
      padding: 6px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Generic section in the toolbar */
    .toolbar-section {
      border: 1px solid #000;
      background-color: #efefef;
      padding: 4px;
      margin: 2px 0;
    }
    .toolbar-section h4 {
      margin: 0 0 4px;
      font-size: 12px;
      font-weight: bold;
      text-align: center;
      background-color: #b0b0b0;
      color: #000;
      border: 1px solid #000;
      padding: 2px;
    }
    .toolbar-section .icon-group {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      justify-content: center;
    }

    .icon {
      width: 30px;
      height: 30px;
      border: 2px solid #000;
      background-color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      user-select: none;
      font-weight: normal;
      position: relative;
    }
    .icon img {
      width: 30px;
      height: 30px;
    }

    /* "ON" label when .icon-active is present */
    .icon.icon-active::after {
      content: "ON";
      position: absolute;
      top: -8px;
      right: -8px;
      background-color: #ff0;
      color: #000;
      font-size: 10px;
      font-weight: bold;
      border: 1px solid #000;
      padding: 2px 4px;
      border-radius: 4px;
      box-shadow: 2px 2px 0px #000;
    }

    /* SHAPE SETTINGS */
    .shape-settings {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .shape-settings label {
      font-size: 12px;
      text-align: center;
      display: block;
    }
    .shape-settings input[type="color"],
    .shape-settings input[type="number"] {
      margin-top: 2px;
      width: 70px;
    }

    /* MAIN DRAWING AREA */
    .main-area {
      flex: 1;
      padding: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #glCanvas {
      width: 500px;
      height: 500px;
      border: 2px solid #000;
      background-color: #fff;
      display: block;
      margin-bottom: 16px;
    }

    /* BOTTOM SLIDER PANEL */
    .bottom-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      border-top: 2px solid #000;
      padding: 8px;
      background-color: #c0c0c0;
      text-align: center;
    }
    #sliders > div {
      display: flex;
      align-items: center;
      margin: 8px 0;
    }
    #sliders label {
      width: 250px;
      text-align: center;
      margin-right: 8px;
    }
    #sliders label span {
      display: inline-block;
      font-weight: bold;
      vertical-align: middle;
    }
    input[type="range"] {
      -webkit-appearance: none;
      width: 250px;
      background: #fff;
      border: 1px solid #000;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 20px;
      background: #c0c0c0;
      border: 1px solid #000;
      cursor: pointer;
      margin-top: -7px;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 20px;
      background: #c0c0c0;
      border: 1px solid #000;
      cursor: pointer;
    }

    /* DIALOGS */
    .dialog-backdrop {
      display: none;
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.4);
      justify-content: center;
      align-items: center;
    }
    .dialog-content {
      background-color: #fff;
      border: 2px solid #000;
      padding: 16px;
      min-width: 200px;
      text-align: center;
      box-shadow: 4px 4px 0px #000;
      font-family: "Courier New", monospace;
    }
    .dialog-content button {
      margin-top: 12px;
      font-family: inherit;
      cursor: pointer;
    }

    /* SPLASH OVERLAY */
    #splashOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      cursor: pointer;
    }
    #splashOverlay img {
      max-width: 50%;
      max-height: 50%;
      pointer-events: none;
      margin-bottom: 50px;
      border: 2px solid #000;
      border-radius: 6px;
      padding: 0px;
    }
    .splashText {
      font-family: "Courier New", monospace;
      font-size: 18px;
      font-weight: bold;
      color: #000;
      background-color: #c0c0c0;
      padding: 8px 12px;
      border: 2px solid #000;
      box-shadow: 4px 4px 0px #000;
      user-select: none;
    }

    /* HELP ICON TOOLTIP */
    .inline-icon {
      width: 16px;
      height: 16px;
      vertical-align: middle;
      margin: 0 4px;
    }
    .help-icon-container {
      position: relative;
      display: inline-block;
    }
    .help-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #c0c0c0; /* retro style */
      border: 1px solid #000;
      color: #000;
      font-size: 12px;
      font-weight: bold;
      text-align: center;
      line-height: 16px;
      cursor: help;
      user-select: none;
    }
    .help-tooltip {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 0;
      min-width: 120px;
      background-color: #efefef;
      color: #000;
      border: 1px solid #000;
      padding: 4px;
      font-size: 12px;
      box-shadow: 4px 4px 0 #000;
      z-index: 9999;
    }
    .help-icon-container:hover .help-tooltip {
      display: block;
    }

    /* CURSOR STYLES FOR EACH MODE */
    .canvas-blob-mode {
      cursor: url("images/Pencil.png"), auto;
    }
    .canvas-line-mode {
      cursor: url("images/Pencil.png"), auto;
    }
    .canvas-circle-mode {
      cursor: url("images/CircleCursor.png"), auto;
    }
    .canvas-drag-mode {
      cursor: url("images/Glove.png"), auto;
    }
    .canvas-pin-mode {
      cursor: url("images/PinCursor.png"), auto;
    }
    .canvas-slicing-mode {
      cursor: url("images/Trim.png"), auto;
    }
    .canvas-freeze-mode {
      cursor: url("images/FreezeCursor.png"), auto;
    }
  </style>
</head>
<body>
<div class="window">
  <!-- Splash Overlay -->
  <div id="splashOverlay">
    <img src="images/splash.png" alt="Splash Image" />
    <div class="splashText">Click and Drag to Start Blobbing</div>
  </div>

  <!-- Title Bar -->
  <div class="title-bar">
    <div class="menu-bar">
      <span id="menuFile">File
        <div class="submenu" id="fileSubmenu">
          <span id="saveBlobsOption">Save Blobs (JSON)</span>
          <span id="saveBlobsSettingsOption">Save Blobs + Settings (JSON)</span>
          <span id="loadBlobsOption">Load Blobs (JSON)</span>
        </div>
      </span>
      <span id="menuExport">Export
        <div class="submenu" id="exportSubmenu">
          <span id="exportStrokedOption">...Lines&gt;SVG</span>
          <span id="exportStrokedJPGOption">...Lines&gt;JPG</span>
          <span id="exportFilledOption">...Fill&gt;SVG</span>
          <span id="exportFilledJPGOption">...Fill&gt;JPG</span>
        </div>
      </span>
      <span id="menuAbout">About</span>
      <span id="menuHelp">Help</span>
    </div>
    <span id="resetIcon" class="reset-icon" title="Reset Canvas">⟳</span>
  </div>

  <!-- Main Content -->
  <div class="content">
    <!-- Toolbar: grouped into Draw Tools, Edit Tools, Canvas Tools, and now Shape Settings -->
    <div class="toolbar">
      <!-- DRAW TOOLS -->
      <div class="toolbar-section">
        <h4>Draw Tools</h4>
        <div class="icon-group">
          <div class="icon" id="iconBlob" title="Blob Mode">
            <img src="images/blob.png" alt="Blob Mode" />
          </div>
          <div class="icon" id="iconLine" title="Line Mode">
            <img src="images/Line.png" alt="Line Mode" />
          </div>
          <div class="icon" id="iconCircle" title="Circle Mode">
            <img src="images/Wrap.png" alt="Circle Mode" />
          </div>
        </div>
      </div>

      <!-- EDIT TOOLS -->
      <div class="toolbar-section">
        <h4>Edit Tools</h4>
        <div class="icon-group">
          <div class="icon" id="iconDrag" title="Enable Drag Mode">
            <img src="images/GloveIcon.png" alt="Drag Mode" />
          </div>
          <div class="icon" id="iconFreeze" title="Enable Freeze Mode">
            <img src="images/Freeze.png" alt="Freeze Mode" />
          </div>
          <div class="icon" id="iconSlice" title="Slicing Mode (Off)">
            <img src="images/Cut.png" alt="Cut Mode" />
          </div>
          <div class="icon" id="iconPin" title="Enable Pin Mode">
            <img src="images/Pin.png" alt="Pin Mode" />
          </div>
        </div>
      </div>

      <!-- SHAPE SETTINGS (Color, Gap, ΔSize) -->
      <div class="toolbar-section">
        <h4>Shape Settings</h4>
        <div class="shape-settings">
          <div>
            <label for="blobColor">Color</label>
            <input type="color" id="blobColor" value="#000000">
          </div>
          <div>
            <label for="radiusAvgInput">Gap</label>
            <input type="number" id="radiusAvgInput" min="0.0" max="20" step="0.2" value="5">
          </div>
          <div>
            <label for="radiusVarInput">ΔSize</label>
            <input type="number" id="radiusVarInput" min="0" max="10" step="0.5" value="2">
          </div>
        </div>
      </div>

      <!-- CANVAS TOOLS -->
      <div class="toolbar-section">
        <h4>Canvas</h4>
        <div class="icon-group">
          <div class="icon" id="iconThickness" title="Line Thickness: Thin">T</div>
          <div class="icon" id="iconUndo" title="Undo Last Item">⎌</div>
        </div>
      </div>
    </div>

    <!-- Main Drawing Area -->
    <div class="main-area">
      <canvas id="glCanvas" width="500" height="500"></canvas>
    </div>
  </div>

  <!-- Bottom Panel: Sliders -->
  <div class="bottom-panel">
    <div id="sliders">
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
             Higher = bigger blobs/lines.
          </div>
        </div>
        <label for="dotScaleSlider" class="slider-label">Blob Size: <span id="dotScaleValue">39%</span></label>
        <input type="range" id="dotScaleSlider" min="0" max="100" value="39" step="0.5">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = more wobble.
          </div>
        </div>
        <label for="dampingSlider">Excitability: <span id="dampingValue">85%</span></label>
        <input type="range" id="dampingSlider" min="0" max="100" value="85" step="0.5">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = tighter shapes.
          </div>
        </div>
        <label for="springConstantSlider">Stiffness: <span id="springConstantValue">30%</span></label>
        <input type="range" id="springConstantSlider" min="0" max="100" value="30" step="1">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = more expansion.
          </div>
        </div>
        <label for="repulsionConstantSlider">Spacing: <span id="repulsionConstantValue">10%</span></label>
        <input type="range" id="repulsionConstantSlider" min="0" max="100" value="10" step="1">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Shapes animate faster when higher.
          </div>
        </div>
        <label for="timeStepSlider">Animation Speed: <span id="timeStepValue">47%</span></label>
        <input type="range" id="timeStepSlider" min="0" max="100" value="47" step="1">
      </div>
    </div>
  </div>

  <!-- Modals/Dialogs: About and Help -->
  <div class="dialog-backdrop" id="aboutBackdrop">
    <div class="dialog-content">
      <p>Blob Maker version 1.0</p>
      <p>by Colin Reid</p>
      <button id="closeAbout">OK</button>
    </div>
  </div>

  <div class="dialog-backdrop" id="helpBackdrop">
    <div class="dialog-content">
      <h3>Instructions</h3>
      <div class="help-text">
        <p><strong>Click and drag to start drawing blobs or lines.</strong></p>
        <p><strong>Blob / Line / Circle:</strong> Choose a draw mode from the "Draw Tools" section. Blob is closed shapes, Line is open paths, Circle draws "repel" circles.</p>
        <p><strong>Edit Tools:</strong> Use Freeze, Drag, Slice (Cut), or Pin to modify existing shapes.</p>
        <p><strong>Shape Settings:</strong> Change the color, gap, and size variation of your shapes.</p>
        <p><strong>Sliders:</strong> Use the physics sliders to control global blob scale, damping, etc.</p>
        <p><strong>Undo:</strong> Click ⎌ to remove the last entire drawn element.</p>
        <p><strong>Save/Load/Export:</strong> Use the <em>File</em> menu for saving/loading shapes and <em>Export</em> for SVG/JPG output.</p>
      </div>
      <button id="closeHelp">OK</button>
    </div>
  </div>
</div>

<script>
if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  document.addEventListener("DOMContentLoaded", function() {
    var warningDiv = document.createElement("div");
    warningDiv.id = "mobileWarning";
    warningDiv.innerHTML = '<h1>Desktop Only</h1><p>This application is best experienced on a desktop browser. Please switch to a desktop device.</p>';
    document.body.appendChild(warningDiv);
  });
}

document.addEventListener("DOMContentLoaded", () => {
  /* -----------------------------------
     SHORTCUTS & UTILITIES
  ----------------------------------- */
  const $ = id => document.getElementById(id);

  // Helper for converting from one numeric range to another
  function mapRange(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  }

  const hexToRGBA = hex => {
    if (hex[0] === "#") hex = hex.slice(1);
    const r = parseInt(hex.slice(0,2),16)/255,
          g = parseInt(hex.slice(2,4),16)/255,
          b = parseInt(hex.slice(4,6),16)/255;
    return [r,g,b,1.0];
  };

  /* -----------------------------------
     SPLASH OVERLAY
  ----------------------------------- */
  $("splashOverlay").onclick = () => {
    $("splashOverlay").style.display = "none";
  };

  /* -----------------------------------
     DIALOG SETUP (ABOUT, HELP)
  ----------------------------------- */
  function setupDialog(openBtnId, backdropId, closeBtnId) {
    const openBtn = $(openBtnId),
          backdrop= $(backdropId),
          closeBtn= $(closeBtnId);
    openBtn.addEventListener("click", () => (backdrop.style.display = "flex"));
    closeBtn.addEventListener("click", () => (backdrop.style.display = "none"));
  }
  setupDialog("menuAbout", "aboutBackdrop", "closeAbout");
  setupDialog("menuHelp", "helpBackdrop", "closeHelp");

  /* -----------------------------------
     FILE & EXPORT MENU
  ----------------------------------- */
  function setupSubmenu(menuId, submenuId) {
    const menu = $(menuId), submenu = $(submenuId);
    let visible = false;
    menu.addEventListener("click", (e) => {
      e.stopPropagation();
      visible = !visible;
      submenu.style.display = visible ? "flex" : "none";
    });
    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && visible) {
        visible = false;
        submenu.style.display = "none";
      }
    });
  }
  setupSubmenu("menuFile", "fileSubmenu");
  setupSubmenu("menuExport", "exportSubmenu");

  /* -----------------------------------
     WEBGL CONTEXT
  ----------------------------------- */
  const canvas = $("glCanvas");
  const gl = canvas.getContext("webgl");
  if (!gl) alert("WebGL not supported by your browser.");

  /* -----------------------------------
     GLOBALS & DATA
  ----------------------------------- */
  // Distinct "draw modes": 'blob', 'line', or 'circle'
  let drawMode = 'blob';

  // Each chain: { chain: [...], color, baseDotRadius, isClosed, frozen }
  const chains = [];
  // Each circle: { x, y, radius }
  const circles = [];
  let history = [];  // For undo

  // Flags for drawing
  let isDrawing          = false,
      isCircleDrawing    = false,
      currentCircle      = null,
      draggingCircleIndex= null;

  // Edit tool flags (only one can be active)
  let slicingMode = false,
      dragMode    = false,
      pinMode     = false,
      freezeMode  = false;

  // For dragging chain points
  let draggingChainIndex = null,
      draggingDotIndex   = null;

  // For hover highlight in pin/drag mode
  let pinHoverChainIndex = null,
      pinHoverDotIndex   = null;

  // Physics parameters (defaults)
  let springConstant      = 0.3,   // from slider ~30%
      repulsionConstant   = 0.1,   // ~10%
      damping             = 0.85,  // ~85%
      timeStep            = 1,     // mapped from 47% => 0.1..2
      dotScaleFactor      = 2.0,   // ~39% => 0.1..5
      currentLineThickness= 1;

  let globalRadiusAvg     = 4,
      globalRadiusVar     = 2;

  const colorInput        = $("blobColor");

  /* -----------------------------------
     ICON "ON" LABEL HELPER
  ----------------------------------- */
  function toggleActiveIcon(iconEl, isActive) {
    iconEl.classList.toggle("icon-active", isActive);
  }

  // A helper to apply the “active” styling to edit-tool icons
  function setIconActive(iconEl, isActive, activeTitle, inactiveTitle) {
    iconEl.title = isActive ? activeTitle : inactiveTitle;
    iconEl.style.backgroundColor = isActive ? "#D3D3D3" : "";
    iconEl.style.fontWeight      = isActive ? "bold" : "normal";
    iconEl.classList.toggle("icon-active", isActive);
  }

  // Ensure only one edit tool is active at a time
  function setEditTool(toolName) {
    // If the requested tool is already active, we’ll toggle it off
    const isAlreadyActive =
      (toolName === "slice"  && slicingMode) ||
      (toolName === "drag"   && dragMode)    ||
      (toolName === "pin"    && pinMode)     ||
      (toolName === "freeze" && freezeMode);

    // First, turn everything off:
    slicingMode = false;
    dragMode    = false;
    pinMode     = false;
    freezeMode  = false;

    // If the requested tool wasn’t already active, we turn it on:
    if (!isAlreadyActive) {
      if (toolName === "slice")  slicingMode = true;
      if (toolName === "drag")   dragMode    = true;
      if (toolName === "pin")    pinMode     = true;
      if (toolName === "freeze") freezeMode  = true;
    }

    // Update icon states accordingly:
    setIconActive($("iconSlice"),  slicingMode,
                  "Slicing Mode (On)", "Slicing Mode (Off)");
    setIconActive($("iconDrag"),   dragMode,
                  "Disable Drag Mode", "Enable Drag Mode");
    setIconActive($("iconPin"),    pinMode,
                  "Disable Pin Mode", "Enable Pin Mode");
    setIconActive($("iconFreeze"), freezeMode,
                  "Disable Freeze Mode", "Enable Freeze Mode");

    // Update the canvas cursor
    updateCanvasCursor();
  }

  /* -----------------------------------
     DRAW MODE: BLOB / LINE / CIRCLE
  ----------------------------------- */
  function setDrawMode(mode) {
    toggleActiveIcon($("iconBlob"),   false);
    toggleActiveIcon($("iconLine"),   false);
    toggleActiveIcon($("iconCircle"), false);

    drawMode = mode;

    if (mode === 'blob') {
      toggleActiveIcon($("iconBlob"), true);
    } else if (mode === 'line') {
      toggleActiveIcon($("iconLine"), true);
    } else if (mode === 'circle') {
      toggleActiveIcon($("iconCircle"), true);
    }
    updateCanvasCursor();
  }
  // Initialize default draw mode
  setDrawMode('blob');

  /* -----------------------------------
     EDIT TOOL ICONS (now calling setEditTool)
  ----------------------------------- */
  $("iconSlice").onclick = function() {
    setEditTool("slice");
  };
  $("iconDrag").onclick = function() {
    setEditTool("drag");
  };
  $("iconPin").onclick = function() {
    setEditTool("pin");
  };
  $("iconFreeze").onclick = function() {
    setEditTool("freeze");
  };

  /* -----------------------------------
     THICKNESS & UNDO & RESET
  ----------------------------------- */
  $("iconThickness").onclick = function() {
    currentLineThickness = (currentLineThickness === 1) ? 5 : 1;
    this.title = (currentLineThickness === 1)
      ? "Line Thickness: Thin"
      : "Line Thickness: Thick";
    this.style.backgroundColor = (currentLineThickness === 5) ? "#D3D3D3" : "";
    this.style.fontWeight      = (currentLineThickness === 5) ? "bold" : "normal";
    toggleActiveIcon(this, currentLineThickness > 1);
  };

  $("iconUndo").onclick = () => {
    if (history.length > 0) {
      const last = history.pop();
      if (last.type === "chain")  chains.pop();
      if (last.type === "circle") circles.pop();
    }
  };

  $("resetIcon").onclick = () => {
    if (confirm("Are you sure you want to clear the entire canvas?")) {
      chains.length = 0;
      circles.length = 0;
      history.length = 0;
    }
  };

  /* -----------------------------------
     DRAW MODE ICONS
  ----------------------------------- */
  $("iconBlob").onclick = () => setDrawMode('blob');
  $("iconLine").onclick = () => {
    if (drawMode === "line") {
      setDrawMode("blob");
    } else {
      setDrawMode("line");
    }
  };
  $("iconCircle").onclick = () => {
    if (drawMode === "circle") {
      setDrawMode("blob");
    } else {
      setDrawMode("circle");
    }
  };

  /* -----------------------------------
     UPDATE CANVAS CURSOR
  ----------------------------------- */
  function updateCanvasCursor() {
    canvas.classList.remove(
      "canvas-blob-mode",
      "canvas-line-mode",
      "canvas-circle-mode",
      "canvas-drag-mode",
      "canvas-pin-mode",
      "canvas-slicing-mode",
      "canvas-freeze-mode"
    );
    // Draw mode
    if (drawMode === 'blob')   canvas.classList.add("canvas-blob-mode");
    if (drawMode === 'line')   canvas.classList.add("canvas-line-mode");
    if (drawMode === 'circle') canvas.classList.add("canvas-circle-mode");

    // Edit tools
    if (slicingMode) canvas.classList.add("canvas-slicing-mode");
    if (dragMode)    canvas.classList.add("canvas-drag-mode");
    if (pinMode)     canvas.classList.add("canvas-pin-mode");
    if (freezeMode)  canvas.classList.add("canvas-freeze-mode");
  }

  /* -----------------------------------
     FILE MENU LOGIC (SAVE/LOAD)
  ----------------------------------- */
  function getCurrentSettings() {
    return {
      timeStep,
      springConstant,
      repulsionConstant,
      damping,
      dotScaleFactor,
      currentLineThickness,
      globalRadiusAvg,
      globalRadiusVar,
      colorValue: colorInput.value
    };
  }
  function applySettings(obj) {
    if (typeof obj.timeStep === "number") {
      timeStep = obj.timeStep;
      $("timeStepSlider").value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
      $("timeStepValue").textContent = $("timeStepSlider").value + "%";
    }
    if (typeof obj.springConstant === "number") {
      springConstant = obj.springConstant;
      $("springConstantSlider").value = springConstant * 100;
      $("springConstantValue").textContent = $("springConstantSlider").value + "%";
    }
    if (typeof obj.repulsionConstant === "number") {
      repulsionConstant = obj.repulsionConstant;
      $("repulsionConstantSlider").value = repulsionConstant * 100;
      $("repulsionConstantValue").textContent = $("repulsionConstantSlider").value + "%";
    }
    if (typeof obj.damping === "number") {
      damping = obj.damping;
      $("dampingSlider").value = damping * 100;
      $("dampingValue").textContent = $("dampingSlider").value + "%";
    }
    if (typeof obj.dotScaleFactor === "number") {
      dotScaleFactor = obj.dotScaleFactor;
      $("dotScaleSlider").value = ((dotScaleFactor - 0.1)/(5 - 0.1))*100;
      $("dotScaleValue").textContent = $("dotScaleSlider").value + "%";
    }
    if (typeof obj.currentLineThickness === "number") {
      currentLineThickness = obj.currentLineThickness;
      $("iconThickness").title = (currentLineThickness === 1)
        ? "Line Thickness: Thin"
        : "Line Thickness: Thick";
      $("iconThickness").style.fontWeight      = (currentLineThickness === 5) ? "bold" : "normal";
      $("iconThickness").style.backgroundColor = (currentLineThickness === 5) ? "#D3D3D3" : "";
      toggleActiveIcon($("iconThickness"), currentLineThickness > 1);
    }
    if (typeof obj.globalRadiusAvg === "number") {
      globalRadiusAvg = obj.globalRadiusAvg;
      $("radiusAvgInput").value = obj.globalRadiusAvg;
    }
    if (typeof obj.globalRadiusVar === "number") {
      globalRadiusVar = obj.globalRadiusVar;
      $("radiusVarInput").value = obj.globalRadiusVar;
    }
    if (typeof obj.colorValue === "string") {
      colorInput.value = obj.colorValue;
    }
  }
  function downloadJSON(filename, dataObj) {
    const dataStr = JSON.stringify(dataObj, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url  = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
  }
  $("saveBlobsOption").onclick = e => {
    e.stopPropagation();
    $("fileSubmenu").style.display = "none";
    downloadJSON("blobs.json", { chains });
  };
  $("saveBlobsSettingsOption").onclick = e => {
    e.stopPropagation();
    $("fileSubmenu").style.display = "none";
    downloadJSON("blobs_with_settings.json", {
      chains,
      settings: getCurrentSettings()
    });
  };
  $("loadBlobsOption").onclick = e => {
    e.stopPropagation();
    $("fileSubmenu").style.display = "none";
    const fileInput = document.createElement("input");
    fileInput.type  = "file";
    fileInput.accept= "application/json";
    fileInput.onchange = ev => {
      const file = ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const imported = JSON.parse(evt.target.result);
          if (imported.chains) {
            imported.chains.forEach(c => chains.push(c));
          }
          if (imported.settings) {
            if (confirm("This file contains settings. Load those settings now?")) {
              applySettings(imported.settings);
            }
          }
        } catch {
          alert("Error parsing JSON file!");
        }
      };
      reader.readAsText(file);
    };
    fileInput.click();
  };

  /* -----------------------------------
     MOUSE EVENTS & DRAWING
  ----------------------------------- */
  let currentPathPoints = [];
  let currentMouseX = 0, currentMouseY = 0;

  canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    currentMouseX = e.clientX - rect.left;
    currentMouseY = e.clientY - rect.top;

    // If drawing a blob or line
    if (isDrawing && (drawMode === 'blob' || drawMode === 'line')) {
      const last = currentPathPoints[currentPathPoints.length - 1];
      const dx = currentMouseX - last.x,
            dy = currentMouseY - last.y;
      if (Math.sqrt(dx*dx + dy*dy) > 1.5) {
        currentPathPoints.push({
          x: currentMouseX, y: currentMouseY,
          vx:0, vy:0,
          pinned:false
        });
      }
    }

    // If resizing a new circle
    if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
      currentCircle.radius = Math.sqrt(
        (currentMouseX - currentCircle.x)**2 +
        (currentMouseY - currentCircle.y)**2
      );
    }

    // If dragging an existing circle
    if (drawMode === 'circle' && dragMode && draggingCircleIndex !== null) {
      circles[draggingCircleIndex].x = currentMouseX;
      circles[draggingCircleIndex].y = currentMouseY;
    }

    // Highlight nearest dot if pinMode/dragMode
    if (pinMode || dragMode) {
      pinHoverChainIndex = null;
      pinHoverDotIndex   = null;

      let bestDist    = Infinity;
      const hoverRad  = 20; // hover radius in px

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = currentMouseX - dot.x;
          const dy  = currentMouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < hoverRad && dist < bestDist) {
            bestDist           = dist;
            pinHoverChainIndex = c;
            pinHoverDotIndex   = i;
          }
        }
      }
    }
  });

  /**
   * Ray-casting test for point-in-polygon
   */
  function pointInPolygon(px, py, polygon) {
    let inside = false;
    for (let i=0, j=polygon.length-1; i<polygon.length; j=i++) {
      const xi = polygon[i].x, yi = polygon[i].y;
      const xj = polygon[j].x, yj = polygon[j].y;
      const intersect = ((yi>py) !== (yj>py)) &&
        (px < (xj - xi)*(py - yi)/(yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX= e.clientX - rect.left;
    const mouseY= e.clientY - rect.top;

    // Circle creation or circle dragging
    if (drawMode === 'circle') {
      if (dragMode) {
        // If we're in dragMode AND circle draw mode, we only do circle dragging:
        // (Try to pick up an existing circle but do NOT create a new one)
        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];
          const dx = mouseX - c.x;
          const dy = mouseY - c.y;
          if (Math.sqrt(dx * dx + dy * dy) < c.radius + 5) {
            draggingCircleIndex = i;
            return;
          }
        }

        // If we didn’t find a circle to drag, just return without creating one:
        return;

      } else {
        // Otherwise (dragMode is OFF), start a new circle
        isCircleDrawing = true;
        currentCircle = { x: mouseX, y: mouseY, radius: 0 };
        return;
      }
    }

    // Slicing mode
    if (slicingMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const sliceRadius  = 15;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < sliceRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        const ch = chains[bestChainIndex].chain;
        if (bestDotIndex > 0 && bestDotIndex < ch.length - 1) {
          const firstHalf = ch.slice(0, bestDotIndex);
          const secondHalf= ch.slice(bestDotIndex);
          chains[bestChainIndex].chain = firstHalf;
          chains.push({
            ...chains[bestChainIndex],
            chain: secondHalf
          });
          history.push({ type: "chain" });
        }
      }
      return;
    }

    // Freeze mode
    if (freezeMode) {
      for (let i=0; i<chains.length; i++) {
        const chainObj = chains[i];
        if (!chainObj.isClosed) continue;  // no interior
        if (pointInPolygon(mouseX, mouseY, chainObj.chain)) {
          chainObj.frozen = !chainObj.frozen;
          return;
        }
      }
      return;
    }

    // Pin mode
    if (pinMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const pickRadius   = 20;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < pickRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        const dot = chains[bestChainIndex].chain[bestDotIndex];
        dot.pinned = !dot.pinned;
        return;
      }
      return;
    }

    // Drag mode
    if (dragMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const pickRadius   = 20;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < pickRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        draggingChainIndex = bestChainIndex;
        draggingDotIndex   = bestDotIndex;
        return;
      }
    }

    // Otherwise, if in blob or line mode, start freehand
    if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
      isDrawing = true;
      currentPathPoints = [{
        x: mouseX, y: mouseY,
        vx:0, vy:0,
        pinned:false
      }];
    }
  });

  window.addEventListener("mouseup", e => {
    if (e.button !== 0) return;

    // Finalize circle
    if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
      if (currentCircle.radius > 5) {
        circles.push(currentCircle);
        history.push({ type: "circle" });
      }
      isCircleDrawing     = false;
      currentCircle       = null;
      draggingCircleIndex = null;
      return;
    }

    // Finalize blob/line
    if (isDrawing && currentPathPoints.length > 2 && (drawMode === 'blob' || drawMode === 'line')) {
      let r = globalRadiusAvg + (Math.random()*2 - 1)*globalRadiusVar;
      if (r < 1) r = 1;
      const chosenColor = hexToRGBA(colorInput.value);

      const isClosed = (drawMode === 'blob');
      if (isClosed) {
        // close shape
        const f = currentPathPoints[0];
        currentPathPoints.push({...f});
      }

      chains.push({
        chain: currentPathPoints.slice(),
        color: chosenColor,
        baseDotRadius: r,
        isClosed,
        frozen: false
      });
      history.push({ type: "chain" });
    }

    // End all "mouseDown" states
    isDrawing          = false;
    draggingChainIndex = null;
    draggingDotIndex   = null;
    draggingCircleIndex= null;
  });

  window.addEventListener("mouseleave", () => {
    isDrawing=false;
    draggingChainIndex=null;
    draggingDotIndex=null;
    draggingCircleIndex=null;
  });

  /* -----------------------------------
     SHADERS & PROGRAM
  ----------------------------------- */
  function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error("Shader compile error:", gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }
  function createProgram(vsSrc, fsSrc) {
    const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
    const p  = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error("Program link error:", gl.getProgramInfoLog(p));
      return null;
    }
    return p;
  }
  const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    void main(){
      vec2 clipSpace = (a_position / u_resolution)*2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace,0,1);
    }
  `;
  const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main(){
      gl_FragColor = u_color;
    }
  `;
  const lineProgram   = createProgram(vsSource, fsSource);
  const linePosLoc    = gl.getAttribLocation(lineProgram, "a_position");
  const lineResLoc    = gl.getUniformLocation(lineProgram, "u_resolution");
  const lineColorLoc  = gl.getUniformLocation(lineProgram, "u_color");
  const positionBuffer= gl.createBuffer();

  /* -----------------------------------
     CATMULL–ROM SPLINE HELPERS
  ----------------------------------- */
  function getClosedSmoothCurve(points, seg=10) {
    const n=points.length; if(n<2) return new Float32Array([]);
    let out=[];
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i],
            p2=points[(i+1)%n],   p3=points[(i+2)%n];
      for(let s=0;s<seg;s++){
        const t=s/seg, t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t2 + (-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t2 + (-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push(x,y);
      }
    }
    out.push(points[0].x, points[0].y);
    return new Float32Array(out);
  }
  function getOpenSmoothCurve(points, seg=10) {
    const n=points.length; if(n<2) return new Float32Array([]);
    let out=[];
    for(let i=0;i<n-1;i++){
      const p0=(i===0 ? points[0] : points[i-1]),
            p1=points[i],   p2=points[i+1],
            p3=(i===n-2 ? points[n-1] : points[i+2]);
      for(let s=0;s<seg;s++){
        const t=s/seg, t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t2 + (-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t2 + (-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push(x,y);
      }
    }
    out.push(points[n-1].x, points[n-1].y);
    return new Float32Array(out);
  }

  function getThickLineVertices(splinePts, thickness) {
    const n = splinePts.length/2;
    let verts=[];
    for(let i=0;i<n;i++){
      const x=splinePts[2*i],   y=splinePts[2*i+1];
      const nxt=(i+1)%n,        prv=(i-1+n)%n;
      const px=splinePts[2*prv],py=splinePts[2*prv+1];
      const nx=splinePts[2*nxt],ny=splinePts[2*nxt+1];
      let tx=nx-px, ty=ny-py, mag=Math.sqrt(tx*tx+ty*ty);
      if(mag<1e-4){ tx=1; ty=0; mag=1; }
      tx/=mag; ty/=mag;
      const nxN=-ty, nyN=tx, half=thickness/2;
      verts.push(x+nxN*half, y+nyN*half, x-nxN*half, y-nyN*half);
    }
    return new Float32Array(verts);
  }

  /* -----------------------------------
     "DASHED" RENDER FOR FROZEN
  ----------------------------------- */
  function drawDashedSpline(spline, color) {
    gl.useProgram(lineProgram);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, color);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    const pts = spline;
    for (let i=0; i<pts.length-3; i+=4) {
      const sub = new Float32Array([
        pts[i],   pts[i+1],
        pts[i+2], pts[i+3]
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, sub, gl.DYNAMIC_DRAW);
      gl.enableVertexAttribArray(linePosLoc);
      gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
      gl.drawArrays(gl.LINE_STRIP, 0, 2);
    }
  }

  /* -----------------------------------
     PHYSICS
  ----------------------------------- */
  function applySpring(chain, forces, i, j, restDist) {
    const a=chain[i], b=chain[j];
    let dx=b.x-a.x, dy=b.y-a.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<1e-4) dist=1e-4;
    const f = springConstant*(dist-restDist), nx=dx/dist, ny=dy/dist;
    forces[i].x+=f*nx; forces[i].y+=f*ny;
    forces[j].x-=f*nx; forces[j].y-=f*ny;
  }

  function simulateChain(chainObj, cIndex) {
    if (chainObj.frozen) return; // skip frozen

    const arr = chainObj.chain;
    const forces = arr.map(()=>({x:0,y:0}));
    const dotR = chainObj.baseDotRadius*dotScaleFactor;
    const restDist = dotR*0.7;

    // Springs
    if(chainObj.isClosed){
      for(let i=0;i<arr.length;i++){
        const j=(i+1)%arr.length;
        applySpring(arr, forces, i, j, restDist);
      }
    } else {
      for(let i=0;i<arr.length-1;i++){
        applySpring(arr, forces, i, i+1, restDist);
      }
    }

    // Self repulsion
    for(let i=0;i<arr.length;i++){
      for(let j=i+1;j<arr.length;j++){
        const a=arr[i], b=arr[j];
        const minD=dotR*2, dx=b.x-a.x, dy=b.y-a.y, dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>0 && dist<minD){
          const overlap = (minD-dist), nx=dx/dist, ny=dy/dist;
          const f=repulsionConstant*overlap;
          forces[i].x-=f*nx; forces[i].y-=f*ny;
          forces[j].x+=f*nx; forces[j].y+=f*ny;
        }
      }
    }

    // Boundary push-back
    for(let i=0;i<arr.length;i++){
      const a=arr[i];
      if(a.x<dotR) forces[i].x += (dotR-a.x)*0.5;
      else if(a.x>canvas.width-dotR)  forces[i].x-= (a.x - (canvas.width-dotR))*0.5;

      if(a.y<dotR) forces[i].y += (dotR-a.y)*0.5;
      else if(a.y>canvas.height-dotR) forces[i].y-= (a.y - (canvas.height-dotR))*0.5;
    }

    // If this chain is currently being dragged
    if(dragMode && cIndex===draggingChainIndex && draggingDotIndex!==null){
      const dot=arr[draggingDotIndex],
            dx=currentMouseX-dot.x,
            dy=currentMouseY-dot.y,
            dist=Math.sqrt(dx*dx + dy*dy);
      if(dist>1e-4){
        const nx=dx/dist, ny=dy/dist, f=0.2*dist;
        forces[draggingDotIndex].x+=f*nx;
        forces[draggingDotIndex].y+=f*ny;
      }
    }

    // Integrate
    for(let i=0;i<arr.length;i++){
      const d=arr[i];
      const isDraggingThisDot = (dragMode && cIndex === draggingChainIndex && i === draggingDotIndex);
      if(d.pinned && !isDraggingThisDot){
        d.vx=0; d.vy=0;
        continue;
      }
      d.vx = (d.vx + forces[i].x*timeStep) * damping;
      d.vy = (d.vy + forces[i].y*timeStep) * damping;
      d.x  += d.vx*timeStep;
      d.y  += d.vy*timeStep;
    }
  }

  function simulateInterChainRepulsion() {
    for(let a=0;a<chains.length;a++){
      for(let b=a+1;b<chains.length;b++){
        const A=chains[a], B=chains[b];
        if(A.frozen && B.frozen) continue;

        const rA=A.baseDotRadius*dotScaleFactor, rB=B.baseDotRadius*dotScaleFactor;
        const minD=rA+rB;
        for(let i=0;i<A.chain.length;i++){
          for(let j=0;j<B.chain.length;j++){
            const dA=A.chain[i], dB=B.chain[j];
            const dx=dB.x-dA.x, dy=dB.y-dA.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist>0 && dist<minD){
              const overlap=(minD-dist), nx=dx/dist, ny=dy/dist, f=repulsionConstant*overlap;
              if(!dA.pinned && !A.frozen){
                dA.vx-=f*nx*timeStep; dA.vy-=f*ny*timeStep;
              }
              if(!dB.pinned && !B.frozen){
                dB.vx+=f*nx*timeStep; dB.vy+=f*ny*timeStep;
              }
            }
          }
        }
      }
    }
  }

  function simulateCircleRepulsion() {
    for(let c=0;c<circles.length;c++){
      const circle=circles[c];
      for(let ch=0;ch<chains.length;ch++){
        if(chains[ch].frozen) continue;
        const arr=chains[ch].chain;
        for(let i=0;i<arr.length;i++){
          const d=arr[i];
          const dx=d.x-circle.x, dy=d.y-circle.y, dist=Math.sqrt(dx*dx+dy*dy);
          if(dist>1e-4 && dist<circle.radius){
            const f=repulsionConstant*(circle.radius-dist);
            if(!d.pinned){
              d.vx+=f*(dx/dist);
              d.vy+=f*(dy/dist);
            }
          }
        }
      }
    }
  }

  /* -----------------------------------
     RENDERING
  ----------------------------------- */
  function drawGrid(size=20) {
    const w=canvas.width, h=canvas.height;
    let gridVerts=[];
    for(let x=0;x<=w;x+=size) {
      gridVerts.push(x,0, x,h);
    }
    for(let y=0;y<=h;y+=size) {
      gridVerts.push(0,y, w,y);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVerts), gl.STATIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform2f(lineResLoc, w,h);
    gl.uniform4fv(lineColorLoc, [0.8,0.8,0.8,1]);
    gl.drawArrays(gl.LINES, 0, gridVerts.length/2);
  }

  function drawPinnedIndicator(x, y) {
    const seg=12, rad=4;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      const cx=x + rad*Math.cos(t), cy=y + rad*Math.sin(t);
      verts.push(cx,cy);
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform4fv(lineColorLoc, [1.0,0.0,0.0,1.0]); // red ring
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawHoverIndicator(dot, isPinned) {
    const seg=12, radius=8;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      verts.push(dot.x + radius*Math.cos(t),
                 dot.y + radius*Math.sin(t));
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
    const color = isPinned ? [1.0, 0.2, 0.2, 1.0] : [0.2, 1.0, 0.2, 1.0];
    gl.uniform4fv(lineColorLoc, color);
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawChain(chainObj, chainIndex) {
    const ch=chainObj.chain;
    if(ch.length<2) return;

    let spline = chainObj.isClosed ? getClosedSmoothCurve(ch,10)
                                   : getOpenSmoothCurve(ch,10);
    if(spline.length<4) return;

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);

    if(chainObj.frozen) {
      // dashed style
      drawDashedSpline(spline, chainObj.color);
    } else {
      // normal stroke
      gl.uniform4fv(lineColorLoc, chainObj.color);
      if(currentLineThickness===1){
        gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.LINE_STRIP,0, spline.length/2);
      } else {
        const thickVerts = getThickLineVertices(spline, currentLineThickness);
        gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0, thickVerts.length/2);
      }
    }

    // pinned dots
    for(let i=0;i<ch.length;i++){
      if(ch[i].pinned){
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        drawPinnedIndicator(ch[i].x, ch[i].y);
      }
    }

    // hover ring if this chain/dot is hovered in pinMode/dragMode
    if((pinMode || dragMode) && chainIndex === pinHoverChainIndex && pinHoverDotIndex!==null){
      const hoverDot = ch[pinHoverDotIndex];
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      drawHoverIndicator(hoverDot, hoverDot.pinned);
    }
  }

  function drawCircle(circle) {
    const seg=32;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      verts.push(
        circle.x + circle.radius*Math.cos(t),
        circle.y + circle.radius*Math.sin(t)
      );
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, [0,0,0,1]);
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawInProgressPath() {
    if(!isDrawing || currentPathPoints.length<2) return;
    const arr=[];
    for(let i=0;i<currentPathPoints.length;i++){
      arr.push(currentPathPoints[i].x, currentPathPoints[i].y);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.DYNAMIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, hexToRGBA(colorInput.value));
    gl.drawArrays(gl.LINE_STRIP, 0, currentPathPoints.length);
  }

  function drawCurrentCircle() {
    if(!isCircleDrawing || !currentCircle) return;
    drawCircle(currentCircle);
  }

  /* -----------------------------------
     ANIMATION LOOP
  ----------------------------------- */
  function animate() {
    // Physics
    chains.forEach((c,i)=>simulateChain(c,i));
    simulateInterChainRepulsion();
    simulateCircleRepulsion();

    // Clear & draw
    gl.clearColor(1,1,1,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    drawGrid(20);

    chains.forEach((chainObj, chainIndex) => {
      drawChain(chainObj, chainIndex);
    });
    drawInProgressPath();
    circles.forEach(drawCircle);
    if(drawMode==='circle') drawCurrentCircle();

    requestAnimationFrame(animate);
  }
  animate();

  /* -----------------------------------
     EXPORT HELPERS
  ----------------------------------- */
  function exportSVG(isFilled) {
    const w=canvas.width, h=canvas.height;
    const parts=[`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" style="background:white;">`];
    chains.forEach(obj=>{
      if(obj.chain.length<2) return;
      const spline = obj.isClosed ? getClosedSmoothCurve(obj.chain,10)
                                  : getOpenSmoothCurve(obj.chain,10);
      if(spline.length<4) return;
      const [rr,gg,bb] = obj.color.map(c=>Math.floor(c*255));
      let d=`M ${spline[0]} ${spline[1]}`;
      for(let i=2;i<spline.length;i+=2) {
        d+=` L ${spline[i]} ${spline[i+1]}`;
      }
      if(obj.isClosed) d+=" Z";

      if(isFilled){
        parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" ${obj.isClosed?`fill="rgb(${rr},${gg},${bb})"`:'fill="none"'} stroke-width="1" stroke-linecap="round" stroke-linejoin="round" />`);
      } else {
        parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" fill="none" stroke-width="${currentLineThickness}" stroke-linecap="round" stroke-linejoin="round" />`);
      }
    });
    parts.push("</svg>");
    const blob=new Blob([parts.join("")],{type:"image/svg+xml"});
    const url=URL.createObjectURL(blob);
    const link=document.createElement("a");
    link.href=url;
    link.download = isFilled ? "blobs_filled.svg" : "blobs_stroked.svg";
    link.click();
    URL.revokeObjectURL(url);
  }

  function exportJPG(isFilled) {
    const size=1500;
    const offscreen=document.createElement("canvas");
    offscreen.width=size;
    offscreen.height=size;
    const ctx=offscreen.getContext("2d");
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,size,size);
    const scale=size/canvas.width;

    chains.forEach(obj=>{
      const ch=obj.chain;
      if(ch.length<2) return;
      const spline = obj.isClosed ? getClosedSmoothCurve(ch,10)
                                  : getOpenSmoothCurve(ch,10);
      if(spline.length<4) return;
      const [rr,gg,bb] = obj.color.map(c=>Math.floor(c*255));
      ctx.lineCap="round";
      ctx.lineJoin="round";
      ctx.beginPath();
      ctx.moveTo(spline[0]*scale, spline[1]*scale);
      for(let i=2;i<spline.length;i+=2){
        ctx.lineTo(spline[i]*scale, spline[i+1]*scale);
      }
      if(obj.isClosed) ctx.closePath();
      if(isFilled && obj.isClosed){
        ctx.fillStyle=`rgb(${rr},${gg},${bb})`;
        ctx.fill();
      } else {
        ctx.strokeStyle=`rgb(${rr},${gg},${bb})`;
        ctx.lineWidth=isFilled?1*scale : currentLineThickness*scale;
        ctx.stroke();
      }
    });

    const url=offscreen.toDataURL("image/jpeg",1.0);
    const link=document.createElement("a");
    link.href=url;
    link.download = isFilled ? "blobs_filled.jpg" : "blobs_stroked.jpg";
    link.click();
  }

  $("exportStrokedOption").onclick = e => {
    e.stopPropagation();
    exportSVG(false);
    $("exportSubmenu").style.display="none";
  };
  $("exportFilledOption").onclick = e => {
    e.stopPropagation();
    exportSVG(true);
    $("exportSubmenu").style.display="none";
  };
  $("exportStrokedJPGOption").onclick = e => {
    e.stopPropagation();
    exportJPG(false);
    $("exportSubmenu").style.display="none";
  };
  $("exportFilledJPGOption").onclick = e => {
    e.stopPropagation();
    exportJPG(true);
    $("exportSubmenu").style.display="none";
  };

  /* -----------------------------------
     SLIDER SETUP
  ----------------------------------- */

  // 1) Blob Scale slider (0..100 => 0.1..5)
  {
    const s = $("dotScaleSlider");
    const v = $("dotScaleValue");
    s.value = ((dotScaleFactor - 0.1)/(5 - 0.1)) * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      const percent = parseFloat(s.value);
      dotScaleFactor = mapRange(percent, 0, 100, 0.1, 5);
      v.textContent = Math.round(s.value) + "%";
    });
  }

  // 2) Damping slider (0..100 => 0..1)
  {
    const s = $("dampingSlider");
    const v = $("dampingValue");
    s.value = damping * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      damping = parseFloat(s.value)/100;
      v.textContent = Math.round(s.value) + "%";
    });
  }

  // 3) Spring Constant slider (0..100 => 0..1)
  {
    const s = $("springConstantSlider");
    const v = $("springConstantValue");
    s.value = springConstant * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      springConstant = parseFloat(s.value)/100;
      v.textContent = Math.round(s.value) + "%";
    });
  }

  // 4) Repulsion slider (0..100 => 0..1)
  {
    const s = $("repulsionConstantSlider");
    const v = $("repulsionConstantValue");
    s.value = repulsionConstant * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      repulsionConstant = parseFloat(s.value)/100;
      v.textContent = s.value + "%";
    });
  }

  // 5) Simulation Speed slider (0..100 => 0.1..2)
  {
    const s = $("timeStepSlider");
    const v = $("timeStepValue");
    s.value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      const percent = parseFloat(s.value);
      timeStep = mapRange(percent, 0, 100, 0.1, 2);
      v.textContent = s.value + "%";
    });
  }

  // 6) Gap & ΔSize
  $("radiusAvgInput").oninput = e => {
    globalRadiusAvg = parseFloat(e.target.value);
  };
  $("radiusVarInput").oninput = e => {
    globalRadiusVar = parseFloat(e.target.value);
  };
});
</script>
</body>
</html>
